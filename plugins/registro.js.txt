import { saveDatabase } from '../lib/db.js'
import { buildUserRecord, sendRegisterCard, sendExistingIdCard } from '../lib/registry.js'
import { prepareWAMessageMedia, generateWAMessageFromContent, getDevice } from '@whiskeysockets/baileys'
import fetch from 'node-fetch'

const sessions = new Map()
const regRecent = new Map()

function toNum(jid = '') { return String(jid).split('@')[0].split(':')[0].replace(/[^0-9]/g, '') }

function mirrorUser(users, numKey, jidKey) {
  if (!users) return
  const a = users[numKey]
  const b = users[jidKey]
  const ref = a || b
  if (!ref) return
  users[numKey] = ref
  users[jidKey] = ref
}

async function askStep(m, conn, step) {
  const prompts = {
    name: 'âš™ï¸ *ğ™´ğš‚ğ™²ğšğ™¸ğ™±ğ™´ ğšƒğš„ ğ™½ğ™¾ğ™¼ğ™±ğšğ™´:*',
    age: 'âš™ï¸ *ğ™¸ğ™½ğ™¶ğšğ™´ğš‚ğ™° ğšƒğš„ ğ™´ğ™³ğ™°ğ™³ (ğŸ·ğŸ¶-ğŸ¿ğŸ¶):*',
    bio: 'âš™ï¸ *ğ™±ğ™¸ğ™¾ ğ™³ğ™´ğš‚ğ™²ğšğ™¸ğ™¿ğ™²ğ™¸ğ™¾Ìğ™½ (ğ™¼ğ™°Ìğš‡ ğŸ¾ğŸ¶ ğ™²ğ™°ğšğ™°ğ™²ğšƒğ™´ğšğ™´ğš‚):*'
  }
  await conn.reply(m.chat, prompts[step], m)
}

async function finalize(m, conn, state, userKey) {
  const num = toNum(m.sender)
  const jidKey = m.sender
  try { regRecent.set(m.sender, Date.now()) } catch {}
  
  // CORRECCIÃ“N: Reemplazar ||= por asignaciÃ³n condicional tradicional
  if (!global.db.data.users) global.db.data.users = {}
  if (!global.db.data.users[num]) {
    global.db.data.users[num] = { exp: 0, coin: 10, level: 0, warns: 0, premium: false, spam: 0 }
  }
  
  const base = global.db.data.users[num]
  const record = buildUserRecord(base, state)
  Object.assign(global.db.data.users[num], record, { registered: true })
  try { mirrorUser(global.db.data.users, num, jidKey) } catch {}
  try { global.db.data.users[jidKey].registered = true } catch {}
  try { await saveDatabase() } catch (e) { console.log('[DB] save error:', e?.message || e) }

  let avatarUrl = ''
  try { avatarUrl = await conn.profilePictureUrl(m.sender, 'image') } catch {}
  if (!avatarUrl) avatarUrl = 'https://image2url.com/images/1765504298320-250ed158-9ddc-49d9-942b-2edfcc711cc8.jpg'

  const userTag = '@' + num
  let autoName = m?.pushName || ''
  try { autoName = (await Promise.resolve(conn.getName?.(m.sender))) || autoName } catch {}
  if (!autoName) autoName = 'ğš„ğš‚ğš„ğ™°ğšğ™¸ğ™¾'
  let quoted = null
  try {
    const res = await fetch('https://image2url.com/images/1765504298320-250ed158-9ddc-49d9-942b-2edfcc711cc8.jpg')
    const thumb2 = Buffer.from(await res.arrayBuffer())
    quoted = {
      key: { participants: '0@s.whatsapp.net', remoteJid: 'status@broadcast', fromMe: false, id: 'Halo' },
      message: { locationMessage: { name: 'âœ… ğšğ™´ğ™¶ğ™¸ğš‚ğšƒğšğ™¾ ğ™²ğ™¾ğ™¼ğ™¿ğ™»ğ™´ğšƒğ™¾', jpegThumbnail: thumb2 } },
      participant: '0@s.whatsapp.net'
    }
  } catch {}
  await sendRegisterCard(conn, m.chat, { userTag, avatarUrl, info: record, participant: m.sender, userName: autoName, title: 'ğšğ™´ğ™¶ğ™¸ğš‚ğšƒğšğ™¾', quoted })
}

let handler = async (m, { conn, args, command, usedPrefix }) => {
  const chatId = m.chat
  const userId = m.sender
  const key = chatId + ':' + userId
  const isCancel = /^cancel(ar)?$/i.test(args[0] || '')

  if (/^reg(istro)?$/i.test(command)) {
    const num = toNum(m.sender)
    const jidKey = m.sender
    const users = (global.db && global.db.data && global.db.data.users) ? global.db.data.users : {}
    try { mirrorUser(users, num, jidKey) } catch {}
    const existing = users[num] || users[jidKey]
    if (existing && (existing.registered || existing.sn)) {
      const last = regRecent.get(m.sender) || 0
      if (Date.now() - last < 3000) return
      if (!existing.sn) {
        existing.sn = 'SN-' + Math.random().toString(36).slice(2, 6).toUpperCase() + '-' + Math.floor(1000 + Math.random() * 9000)
        try { await saveDatabase() } catch {}
      }
      let displayName = m?.pushName || ''
      try { displayName = (await Promise.resolve(conn.getName?.(m.sender))) || displayName } catch {}
      if (!displayName) displayName = 'ğš„ğš‚ğš„ğ™°ğšğ™¸ğ™¾'
      await sendExistingIdCard(conn, m.chat, { participant: m.sender, userName: displayName, existing })
      return
    }
    
    let autoName = m?.pushName || ''
    try { autoName = (await Promise.resolve(conn.getName?.(m.sender))) || autoName } catch {}
    if (!autoName) autoName = 'ğš„ğš‚ğš„ğ™°ğšğ™¸ğ™¾'

    let avatarUrl = ''
    try { avatarUrl = await conn.profilePictureUrl(m.sender, 'image') } catch {}
    if (!avatarUrl) avatarUrl = 'https://image2url.com/images/1765504298320-250ed158-9ddc-49d9-942b-2edfcc711cc8.jpg'

    let fkontak = m
    try {
      const res = await fetch('https://image2url.com/images/1765504298320-250ed158-9ddc-49d9-942b-2edfcc711cc8.jpg')
      const thumb2 = Buffer.from(await res.arrayBuffer())
      fkontak = {
        key: { participants: '0@s.whatsapp.net', remoteJid: 'status@broadcast', fromMe: false, id: 'Halo' },
        message: { locationMessage: { name: 'âš™ï¸ ğšğ™´ğ™¶ğ™¸ğš‚ğšƒğšğ™¾', jpegThumbnail: thumb2 } },
        participant: '0@s.whatsapp.net'
      }
    } catch {}

    const minAge = 17, maxAge = 30
    const rows = []
    for (let i = minAge; i <= maxAge; i++) {
      rows.push({ header: `ğ™´ğ™³ğ™°ğ™³ ${i}`, title: autoName, description: 'ğš‚ğ™´ğ™»ğ™´ğ™²ğ™²ğ™¸ğ™¾ğ™½ğ™°ğš ğ™´ğš‚ğšƒğ™° ğ™´ğ™³ğ™°ğ™³', id: `${usedPrefix}regok ${i}` })
    }

    try {
      const device = await getDevice(m.key.id)
      if (device !== 'desktop' && device !== 'web') {
        const media = await prepareWAMessageMedia({ image: { url: avatarUrl } }, { upload: conn.waUploadToServer })
        const interactiveMessage = {
          body: { text: `âš™ï¸ *ğšğ™´ğ™¶ğ™¸ğš‚ğšƒğšğ™¾ ğšğ™°Ìğ™¿ğ™¸ğ™³ğ™¾*\n\nğŸ“ ğ™½ğ™¾ğ™¼ğ™±ğšğ™´: ${autoName}\nğŸ‚ ğš‚ğ™´ğ™»ğ™´ğ™²ğ™²ğ™¸ğ™¾ğ™½ğ™° ğšƒğš„ ğ™´ğ™³ğ™°ğ™³:` },
          footer: { text: `âš™ï¸ ğ™ºğ™°ğšğ™±ğ™¾ğšƒ` },
          header: { title: '', hasMediaAttachment: true, imageMessage: media.imageMessage },
          nativeFlowMessage: {
            buttons: [
              {
                name: 'single_select',
                buttonParamsJson: JSON.stringify({
                  title: 'ğ™´ğ™»ğ™¸ğ™¶ğ™´ ğšƒğš„ ğ™´ğ™³ğ™°ğ™³',
                  sections: [ { title: 'ğ™´ğ™³ğ™°ğ™³ğ™´ğš‚', rows } ]
                })
              }
            ],
            messageParamsJson: ''
          }
        }
        const msg = generateWAMessageFromContent(m.chat, { viewOnceMessage: { message: { interactiveMessage } } }, { userJid: conn.user.jid, quoted: fkontak })
        await conn.relayMessage(m.chat, msg.message, { messageId: msg.key.id })
        return
      }
    } catch {}

    const list = Array.from({ length: 30 - 17 + 1 }, (_, k) => 17 + k).map(n => `â€¢ ${usedPrefix}regok ${n}`).join('\n')
    await conn.sendMessage(m.chat, { text: `âš™ï¸ *ğšğ™´ğ™¶ğ™¸ğš‚ğšƒğšğ™¾ ğšğ™°Ìğ™¿ğ™¸ğ™³ğ™¾*\n\nğŸ“ ğ™½ğ™¾ğ™¼ğ™±ğšğ™´: ${autoName}\nğŸ‚ ğ™´ğ™»ğ™¸ğ™¶ğ™´ ğšƒğš„ ğ™´ğ™³ğ™°ğ™³:\n\n${list}` }, { quoted: fkontak })
    return
  }

  if (isCancel) {
    if (sessions.has(key)) { sessions.delete(key); await conn.reply(m.chat, 'âš™ï¸ ğšğ™´ğ™¶ğ™¸ğš‚ğšƒğšğ™¾ ğ™²ğ™°ğ™½ğ™²ğ™´ğ™»ğ™°ğ™³ğ™¾', m) }
    else await conn.reply(m.chat, 'âš™ï¸ ğ™½ğ™¾ ğšƒğ™¸ğ™´ğ™½ğ™´ğš‚ ğšğ™´ğ™¶ğ™¸ğš‚ğšƒğšğ™¾ ğ™´ğ™½ ğ™²ğš„ğšğš‚ğ™¾', m)
    return
  }

  if (/^regok$/i.test(command)) {
    const num = toNum(m.sender)
    const jidKey = m.sender
    const users = (global.db && global.db.data && global.db.data.users) ? global.db.data.users : {}
    try { mirrorUser(users, num, jidKey) } catch {}
    const existing = users[num] || users[jidKey]
    if (existing && (existing.registered || existing.sn)) {
      const last = regRecent.get(m.sender) || 0
      if (Date.now() - last < 3000) return
      if (!existing.sn) {
        existing.sn = 'SN-' + Math.random().toString(36).slice(2, 6).toUpperCase() + '-' + Math.floor(1000 + Math.random() * 9000)
        try { await saveDatabase() } catch {}
      }
      let displayName = m?.pushName || ''
      try { displayName = (await Promise.resolve(conn.getName?.(m.sender))) || displayName } catch {}
      if (!displayName) displayName = 'ğš„ğš‚ğš„ğ™°ğšğ™¸ğ™¾'
      await sendExistingIdCard(conn, m.chat, { participant: m.sender, userName: displayName, existing })
      return
    }
    const age = parseInt(args[0])
    if (isNaN(age) || age < 10 || age > 90) {
      await conn.reply(m.chat, 'âš™ï¸ ğ™´ğ™³ğ™°ğ™³ ğ™¸ğ™½ğš…ğ™°Ìğ™»ğ™¸ğ™³ğ™°\nğš„ğš‚ğ™°: .regok 20', m)
      return
    }
    let autoName = m?.pushName || ''
    try { autoName = (await Promise.resolve(conn.getName?.(m.sender))) || autoName } catch {}
    if (!autoName) autoName = 'ğš„ğš‚ğš„ğ™°ğšğ™¸ğ™¾'
    const state = { name: autoName, age, bio: 'ğš‚ğ™¸ğ™½ ğ™±ğ™¸ğ™¾' }
    try { regRecent.set(m.sender, Date.now()) } catch {}
    sessions.delete(key)
    return finalize(m, conn, state, key)
  }

  const ses = sessions.get(key)
  if (!ses) return
  const text = (m.text || '').trim()

  if (ses.step === 'name') {
    if (!text || text.length < 2 || text.length > 30) {
      await conn.reply(m.chat, 'âš™ï¸ ğ™½ğ™¾ğ™¼ğ™±ğšğ™´ ğ™¸ğ™½ğš…ğ™°Ìğ™»ğ™¸ğ™³ğ™¾\nğŸ¸-ğŸ¹ğŸ¶ ğ™²ğ™°ğšğ™°ğ™²ğšƒğ™´ğšğ™´ğš‚', m)
      return askStep(m, conn, 'name')
    }
    ses.name = text
    ses.step = 'age'
    return askStep(m, conn, 'age')
  }

  if (ses.step === 'age') {
    const n = parseInt(text)
    if (isNaN(n) || n < 10 || n > 90) {
      await conn.reply(m.chat, 'âš™ï¸ ğ™´ğ™³ğ™°ğ™³ ğ™¸ğ™½ğš…ğ™°Ìğ™»ğ™¸ğ™³ğ™°\nğŸ·ğŸ¶-ğŸ¿ğŸ¶ ğ™°ğ™½Ìƒğ™¾ğš‚', m)
      return askStep(m, conn, 'age')
    }
    ses.age = n
    ses.step = 'bio'
    return askStep(m, conn, 'bio')
  }

  if (ses.step === 'bio') {
    if (!text || text.length > 80) {
      await conn.reply(m.chat, 'âš™ï¸ ğ™±ğ™¸ğ™¾ ğ™¸ğ™½ğš…ğ™°Ìğ™»ğ™¸ğ™³ğ™°\nğ™¼ğ™°Ìğš‡ ğŸ¾ğŸ¶ ğ™²ğ™°ğšğ™°ğ™²ğšƒğ™´ğšğ™´ğš‚', m)
      return askStep(m, conn, 'bio')
    }
    ses.bio = text
    sessions.delete(key)
    return finalize(m, conn, ses, key)
  }
}

handler.help = ['registro', 'reg', 'regok <edad>', 'cancel']
handler.tags = ['user']
handler.command = /^(registro|reg|regok|cancel)$/i

handler.before = async function (m, { conn }) {
  const key = m.chat + ':' + m.sender
  const ses = sessions.get(key)
  
  try {
    const msg = m.message || {}
    let selectedId = null
    const irm = msg.interactiveResponseMessage
    if (!selectedId && irm && irm.nativeFlowResponseMessage) {
      try {
        const params = JSON.parse(irm.nativeFlowResponseMessage.paramsJson || '{}')
        if (params && typeof params.id === 'string') selectedId = params.id
        if (!selectedId && typeof params.selectedId === 'string') selectedId = params.selectedId
        if (!selectedId && typeof params.rowId === 'string') selectedId = params.rowId
      } catch {}
    }
    const lrm = msg.listResponseMessage
    if (!selectedId && lrm && lrm.singleSelectReply && lrm.singleSelectReply.selectedRowId) {
      selectedId = lrm.singleSelectReply.selectedRowId
    }
    const brm = msg.buttonsResponseMessage
    if (!selectedId && brm && typeof brm.selectedButtonId === 'string') {
      selectedId = brm.selectedButtonId
    }
    
    if (selectedId && /\bregok\b/i.test(selectedId)) {
      let age = NaN
      let m1 = selectedId.match(/regok\s+(\d{1,2})/i)
      if (m1) age = parseInt(m1[1])
      if (isNaN(age)) {
        const m2 = selectedId.match(/(\d{1,2})\b/)
        if (m2) age = parseInt(m2[1])
      }
      if (!isNaN(age) && age >= 10 && age <= 90) {
        const num = toNum(m.sender)
        const jidKey = m.sender
        const users = (global.db && global.db.data && global.db.data.users) ? global.db.data.users : {}
        try { mirrorUser(users, num, jidKey) } catch {}
        const existing = users[num] || users[jidKey]
        if (existing && (existing.registered || existing.sn)) {
          const last = regRecent.get(m.sender) || 0
          if (Date.now() - last < 3000) return true
          if (!existing.sn) {
            existing.sn = 'SN-' + Math.random().toString(36).slice(2, 6).toUpperCase() + '-' + Math.floor(1000 + Math.random() * 9000)
            try { await saveDatabase() } catch {}
          }
          let displayName = m?.pushName || ''
          try { displayName = (await Promise.resolve(conn.getName?.(m.sender))) || displayName } catch {}
          if (!displayName) displayName = 'ğš„ğš‚ğš„ğ™°ğšğ™¸ğ™¾'
          await sendExistingIdCard(conn, m.chat, { participant: m.sender, userName: displayName, existing })
          return true
        }
        let autoName = m?.pushName || ''
        try { autoName = (await Promise.resolve(conn.getName?.(m.sender))) || autoName } catch {}
        if (!autoName) autoName = 'ğš„ğš‚ğš„ğ™°ğšğ™¸ğ™¾'
        const state = { name: autoName, age, bio: 'ğš‚ğ™¸ğ™½ ğ™±ğ™¸ğ™¾' }
        try { regRecent.set(m.sender, Date.now()) } catch {}
        sessions.delete(key)
        await finalize(m, conn, state, key)
        return true
      }
    }
  } catch {}

  if (!ses) return false
  const text = (m.text || '').trim()
  const prefixes = Array.isArray(global.prefixes) && global.prefixes.length ? global.prefixes : ['.', '!', '/']
  const startsWithPrefix = prefixes.some(p => text.startsWith(p))
  if (startsWithPrefix && !/^\.?cancel(ar)?$/i.test(text)) return false

  if (ses.step === 'name') {
    if (!text || text.length < 2 || text.length > 30) {
      await this.reply(m.chat, 'âš™ï¸ ğ™½ğ™¾ğ™¼ğ™±ğšğ™´ ğ™¸ğ™½ğš…ğ™°Ìğ™»ğ™¸ğ™³ğ™¾\nğŸ¸-ğŸ¹ğŸ¶ ğ™²ğ™°ğšğ™°ğ™²ğšƒğ™´ğšğ™´ğš‚', m)
      return askStep(m, this, 'name'), true
    }
    ses.name = text
    ses.step = 'age'
    return askStep(m, this, 'age'), true
  }
  if (ses.step === 'age') {
    const n = parseInt(text)
    if (isNaN(n) || n < 10 || n > 90) {
      await this.reply(m.chat, 'âš™ï¸ ğ™´ğ™³ğ™°ğ™³ ğ™¸ğ™½ğš…ğ™°Ìğ™»ğ™¸ğ™³ğ™°\nğŸ·ğŸ¶-ğŸ¿ğŸ¶ ğ™°ğ™½Ìƒğ™¾ğš‚', m)
      return askStep(m, this, 'age'), true
    }
    ses.age = n
    ses.step = 'bio'
    return askStep(m, this, 'bio'), true
  }
  if (ses.step === 'bio') {
    if (!text || text.length > 80) {
      await this.reply(m.chat, 'âš™ï¸ ğ™±ğ™¸ğ™¾ ğ™¸ğ™½ğš…ğ™°Ìğ™»ğ™¸ğ™³ğ™°\nğ™¼ğ™°Ìğš‡ ğŸ¾ğŸ¶ ğ™²ğ™°ğšğ™°ğ™²ğšƒğ™´ğšğ™´ğš‚', m)
      return askStep(m, this, 'bio'), true
    }
    ses.bio = text
    sessions.delete(key)
    await finalize(m, this, ses, key)
    return true
  }
  return false
}

export default handler